import React, {
  Fragment,
  ReactNode,
  useCallback,
  useEffect,
  useRef,
  useState,
  VoidFunctionComponent,
} from "react";
import { createPortal } from "react-dom";
import { v4 as uuid } from "uuid";
import { Schema } from "prosemirror-model";
import { Plugin } from "prosemirror-state";
import { defineNewBlock, renderPM } from "./sandbox";
import { baseSchemaConfig } from "./config";
import {
  Block,
  BlockMeta,
  blockPaths,
  BlockWithoutMeta,
  componentIdToName,
  ReplacePortals,
} from "./tsUtils";
import { Text } from "../../graphql/autoGeneratedTypes";
import { useBlockProtocolUpdate } from "../../components/hooks/blockProtocolFunctions/useBlockProtocolUpdate";
import { BlockProtocolUpdatePayload } from "../../types/blockProtocol";

const invertedBlockPaths = Object.fromEntries(
  Object.entries(blockPaths).map(([key, value]) => [value, key])
);

type PageBlockProps = {
  contents: (Block | BlockWithoutMeta)[];
  blocksMeta: Map<string, BlockMeta>;
  pageId: string;
  namespaceId: string;
};

type PortalSet = Map<HTMLElement, { key: string; reactNode: ReactNode }>;

export const PageBlock: VoidFunctionComponent<PageBlockProps> = ({
  contents,
  blocksMeta,
  pageId,
  namespaceId,
}) => {
  const root = useRef<HTMLDivElement>(null);
  const [portals, setPortals] = useState<PortalSet>(new Map());
  const { update } = useBlockProtocolUpdate();

  const portalQueue = useRef<((set: PortalSet) => void)[]>([]);
  const portalQueueTimeout =
    useRef<ReturnType<typeof setImmediate> | null>(null);

  const replacePortal = useCallback<ReplacePortals>(
    (existingNode, nextNode, reactNode) => {
      if (portalQueueTimeout.current !== null) {
        clearImmediate(portalQueueTimeout.current);
      }

      portalQueue.current.push((nextPortals) => {
        if (existingNode && existingNode !== nextNode) {
          nextPortals.delete(existingNode);
        }

        if (nextNode && reactNode) {
          const key = nextPortals.get(nextNode)?.key ?? uuid();

          nextPortals.set(nextNode, { key, reactNode });
        }
      });

      portalQueueTimeout.current = setImmediate(() => {
        const queue = portalQueue.current;
        portalQueue.current = [];

        setPortals((portals) => {
          const nextPortals = new Map(portals);

          for (const cb of queue) {
            cb(nextPortals);
          }

          return nextPortals;
        });
      });
    },
    []
  );

  const saveTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    return () => {
      if (saveTimer.current !== null) {
        clearTimeout(saveTimer.current);
      }

      if (portalQueueTimeout.current !== null) {
        clearImmediate(portalQueueTimeout.current);
      }
    };
  }, []);

  useEffect(() => {
    const schema = new Schema(baseSchemaConfig);

    const savePlugin = new Plugin({
        props: {
          handleDOMEvents: {
            focus() {
              if (saveTimer.current) {
                clearTimeout(saveTimer.current);
                saveTimer.current = null;
              }
              return false;
            },
            blur: function (view) {
              if (saveTimer.current) {
                clearTimeout(saveTimer.current);
                saveTimer.current = null;
              }

              saveTimer.current = setTimeout(() => {
                const blocks = view.state
                  .toJSON()
                  .doc.content.filter((block: any) => block.type === "block")
                  .flatMap((block: any) => block.content) as any[];

                const mappedBlocks = blocks.map((node: any) => {
                  const nodeType = view.state.schema.nodes[node.type];
                  const meta = nodeType.defaultAttrs.meta;

                  const componentId = invertedBlockPaths[meta.url] ?? meta.url;

                  let entity;
                  if (schema.nodes[node.type].isTextblock) {
                    entity = {
                      type: "Text",
                      id: node.attrs.childEntityId,
                      properties: {
                        texts:
                          node.content
                            ?.filter((child: any) => child.type === "text")
                            .map((child: any) => ({
                              text: child.text,
                              bold:
                                child.marks?.some(
                                  (mark: any) => mark.type === "strong"
                                ) ?? false,
                              italics:
                                child.marks?.some(
                                  (mark: any) => mark.type === "em"
                                ) ?? false,
                              underline:
                                child.marks?.some(
                                  (mark: any) => mark.type === "underlined"
                                ) ?? false,
                            })) ?? [],
                      },
                    };
                  } else {
                    const { childEntityId, ...props } = node.attrs;
                    entity = {
                      type: "UnknownEntity",
                      id: childEntityId,
                      properties: props,
                    };
                  }

                  return {
                    entityId: node.attrs.entityId,
                    type: "Block",
                    properties: {
                      componentId,
                      entity,
                    },
                  };
                });

                const newBlocks = mappedBlocks.filter(
                  (block) =>
                    !contents.some(
                      (content) => content.entityId === block.entityId
                    )
                );

                const existingBlocks = mappedBlocks.filter((block) =>
                  contents.some(
                    (content) => content.entityId === block.entityId
                  )
                );

                const updatedEntities = existingBlocks.map(
                  (block) => block.properties.entity
                );

                console.log({ newBlocks, updatedEntities });

                //
                // const updatedEntities = blocks.reduce<
                //   Pick<Text, "id" | "properties" | "type">[]
                // >((entities, node: any) => {
                //   // const nodeType = view.state.schema.nodes[node.type];
                //   // const meta = nodeType.defaultAttrs.meta;
                //
                //   // const componentId =
                //   //   invertedBlockPaths[meta.url] ?? meta.url;
                //
                //
                //   if (schema.nodes[node.type].isTextblock) {
                //     entities.push({
                //       type: "Text",
                //       id: node.attrs.childEntityId,
                //       properties: {
                //         texts:
                //           node.content
                //             ?.filter((child: any) => child.type === "text")
                //             .map((child: any) => ({
                //               text: child.text,
                //               bold:
                //                 child.marks?.some(
                //                   (mark: any) => mark.type === "strong"
                //                 ) ?? false,
                //               italics:
                //                 child.marks?.some(
                //                   (mark: any) => mark.type === "em"
                //                 ) ?? false,
                //               underline:
                //                 child.marks?.some(
                //                   (mark: any) => mark.type === "underlined"
                //                 ) ?? false,
                //             })) ?? [],
                //       },
                //     });
                //   } else {
                //     const { childEntityId, ...props } = node.attrs;
                //     entities.push({
                //       type: "UnknownEntity",
                //       id: childEntityId,
                //       properties: props,
                //     });
                //   }
                //
                //   return entities;
                // }, []);
                //
                // const newBlocks = blocks
                //   .filter((node) => {
                //     return !contents.some(
                //       (content) => content.entityId === node.attrs.entityId
                //     );
                //   })
                //   .map((node) => {
                //     const nodeType = view.state.schema.nodes[node.type];
                //     const meta = nodeType.defaultAttrs.meta;
                //
                //     const componentId =
                //       invertedBlockPaths[meta.url] ?? meta.url;
                //
                //     return {
                //       entityId: node.attrs.entityId,
                //       type: "Block",
                //       properties: {
                //         componentId,
                //         entity: updatedEntities.find(
                //           (entity) => entity.id === node.attrs.childEntityId
                //         ),
                //       },
                //     };
                //   });
                //
                // console.log(newBlocks);
                //
                // // const pageBlocks = blocks.map((node) => {
                // //   // const nodeType = view.state.schema.nodes[node.type];
                // //   // const meta = nodeType.defaultAttrs.meta;
                // //   //
                // //   // const componentId = invertedBlockPaths[meta.url] ?? meta.url;
                // //
                // //   return {
                // //     entityId: node.attrs.entityId,
                // //     type: "Block",
                // //   };
                // // });
                //
                update([
                  ...updatedEntities
                    // We're only responsible for updating contents of text entities
                    .filter((entity) => entity.type === "Text")
                    .map(
                      (entity): BlockProtocolUpdatePayload<any> => ({
                        entityId: entity.id,
                        entityType: entity.type,
                        data: entity.properties,
                      })
                    ),
                  // {
                  //   entityType: "Page",
                  //   entityId: pageId,
                  //   data: {
                  //     contents: pageBlocks,
                  //   },
                  // },
                ]);
              }, 500);

              return false;
            },
          },
        },
      }),
      view = renderPM(
        root.current!,
        schema.node(
          "doc",
          {},
          contents?.map((block) => {
            const { children, ...props } = block.entity;

            return schema.node(
              "async",
              {
                autofocus: false,
                asyncNodeUrl: block.componentId,
                asyncNodeProps: {
                  attrs: {
                    props,
                    entityId: block.entityId,
                    // @todo set this properly
                    childEntityId: children?.[0]?.entityId ?? null,
                  },
                  children:
                    children?.map((child: any) => {
                      if (child.type === "text") {
                        return schema.text(
                          child.text,
                          child.marks.map((mark: string) => schema.mark(mark))
                        );
                      }

                      // @todo recursive nodes
                      throw new Error("unrecognised child");
                    }) ?? [],
                },
              },
              []
            );
          }) ?? []
        ),
        { nodeViews: {} },
        replacePortal,
        [savePlugin]
      );

    setPortals(new Map());

    for (const [url, meta] of Array.from(blocksMeta.entries())) {
      defineNewBlock(
        meta.componentMetadata,
        meta.componentSchema,
        view,
        componentIdToName(url),
        replacePortal
      );
    }

    const node = root.current!;

    return () => {
      node.innerHTML = "";
    };
  }, [contents]);

  return (
    <>
      <div id="root" ref={root} />
      {Array.from(portals.entries()).map(([target, { key, reactNode }]) => (
        <Fragment key={key}>{createPortal(reactNode, target)}</Fragment>
      ))}
    </>
  );
};
