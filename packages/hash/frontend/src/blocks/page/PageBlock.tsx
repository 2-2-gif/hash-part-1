import React, {
  Fragment,
  ReactNode,
  useCallback,
  useEffect,
  useRef,
  useState,
  VoidFunctionComponent,
} from "react";
import { createPortal } from "react-dom";
import { v4 as uuid } from "uuid";
import { Schema } from "prosemirror-model";
import { Plugin } from "prosemirror-state";
import { defineNewBlock, renderPM } from "./sandbox";
import { baseSchemaConfig } from "./config";
import {
  Block,
  BlockMeta,
  BlockWithoutMeta,
  componentIdToName,
  ReplacePortals,
} from "./tsUtils";
import { Text } from "../../graphql/autoGeneratedTypes";
import { useBlockProtocolUpdate } from "../../components/hooks/blockProtocolFunctions/useBlockProtocolUpdate";
import { entities } from "@hashintel/hash-backend/mockData/entities";
import { BlockProtocolUpdatePayload } from "../../types/blockProtocol";
import { properties } from "@hashintel/hash-backend/graphql/resolvers/entity/properties";

// const invertedBlockPaths = Object.fromEntries(
//   Object.entries(blockPaths).map(([key, value]) => [value, key])
// );

type PageBlockProps = {
  contents: (Block | BlockWithoutMeta)[];
  blocksMeta: Map<string, BlockMeta>;
  pageId: string;
  namespaceId: string;
};

type PortalSet = Map<HTMLElement, { key: string; reactNode: ReactNode }>;

export const PageBlock: VoidFunctionComponent<PageBlockProps> = ({
  contents,
  blocksMeta,
  pageId,
  namespaceId,
}) => {
  const root = useRef<HTMLDivElement>(null);
  const [portals, setPortals] = useState<PortalSet>(new Map());
  const { update } = useBlockProtocolUpdate();

  const portalQueue = useRef<((set: PortalSet) => void)[]>([]);
  const portalQueueTimeout =
    useRef<ReturnType<typeof setImmediate> | null>(null);

  const replacePortal = useCallback<ReplacePortals>(
    (existingNode, nextNode, reactNode) => {
      if (portalQueueTimeout.current !== null) {
        clearImmediate(portalQueueTimeout.current);
      }

      portalQueue.current.push((nextPortals) => {
        if (existingNode && existingNode !== nextNode) {
          nextPortals.delete(existingNode);
        }

        if (nextNode && reactNode) {
          const key = nextPortals.get(nextNode)?.key ?? uuid();

          nextPortals.set(nextNode, { key, reactNode });
        }
      });

      portalQueueTimeout.current = setImmediate(() => {
        const queue = portalQueue.current;
        portalQueue.current = [];

        setPortals((portals) => {
          const nextPortals = new Map(portals);

          for (const cb of queue) {
            cb(nextPortals);
          }

          return nextPortals;
        });
      });
    },
    []
  );

  const saveTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    return () => {
      if (saveTimer.current !== null) {
        clearTimeout(saveTimer.current);
      }

      if (portalQueueTimeout.current !== null) {
        clearImmediate(portalQueueTimeout.current);
      }
    };
  }, []);

  useEffect(() => {
    const schema = new Schema(baseSchemaConfig);

    const savePlugin = new Plugin({
        props: {
          handleDOMEvents: {
            focus() {
              if (saveTimer.current) {
                clearTimeout(saveTimer.current);
                saveTimer.current = null;
              }
              return false;
            },
            blur(view) {
              if (saveTimer.current) {
                clearTimeout(saveTimer.current);
                saveTimer.current = null;
              }

              saveTimer.current = setTimeout(() => {
                const updatedEntities = (
                  view.state
                    .toJSON()
                    .doc.content.filter((block: any) => block.type === "block")
                    .flatMap((block: any) => block.content) as any[]
                ).reduce<Pick<Text, "id" | "properties" | "type">[]>(
                  (entities, node: any) => {
                    // const nodeType = view.state.schema.nodes[node.type];
                    // const meta = nodeType.defaultAttrs.meta;

                    // const componentId =
                    //   invertedBlockPaths[meta.url] ?? meta.url;

                    if (
                      node.content?.every((node: any) => node.type === "text")
                    ) {
                      entities.push({
                        type: "Text",
                        id: node.attrs.childEntityId,
                        properties: {
                          texts: node.content
                            .filter((child: any) => child.type === "text")
                            .map((child: any) => ({
                              text: child.text,
                              bold:
                                child.marks?.some(
                                  (mark: any) => mark.type === "strong"
                                ) ?? false,
                              italics:
                                child.marks?.some(
                                  (mark: any) => mark.type === "em"
                                ) ?? false,
                              underline:
                                child.marks?.some(
                                  (mark: any) => mark.type === "underlined"
                                ) ?? false,
                            })),
                        },
                      });
                    }

                    return entities;
                  },
                  []
                );

                update(
                  updatedEntities.map(
                    (entity): BlockProtocolUpdatePayload<any> => ({
                      entityId: entity.id,
                      entityType: entity.type,
                      data: entity.properties,
                    })
                  )
                );
              }, 500);

              return false;
            },
          },
        },
      }),
      view = renderPM(
        root.current!,
        schema.node(
          "doc",
          {},
          contents?.map((block) => {
            const { children, ...props } = block.entity;

            return schema.node(
              "async",
              {
                autofocus: false,
                asyncNodeUrl: block.componentId,
                asyncNodeProps: {
                  attrs: {
                    props,
                    entityId: block.entityId,
                    // @todo set this properly
                    childEntityId: children?.[0]?.entityId ?? null,
                  },
                  children:
                    children?.map((child: any) => {
                      if (child.type === "text") {
                        return schema.text(
                          child.text,
                          child.marks.map((mark: string) => schema.mark(mark))
                        );
                      }

                      // @todo recursive nodes
                      throw new Error("unrecognised child");
                    }) ?? [],
                },
              },
              []
            );
          }) ?? []
        ),
        { nodeViews: {} },
        replacePortal,
        [savePlugin]
      );

    setPortals(new Map());

    for (const [url, meta] of Array.from(blocksMeta.entries())) {
      defineNewBlock(
        meta.componentMetadata,
        meta.componentSchema,
        view,
        componentIdToName(url),
        replacePortal
      );
    }

    const node = root.current!;

    return () => {
      node.innerHTML = "";
    };
  }, [contents]);

  return (
    <>
      <div id="root" ref={root} />
      {Array.from(portals.entries()).map(([target, { key, reactNode }]) => (
        <Fragment key={key}>{createPortal(reactNode, target)}</Fragment>
      ))}
    </>
  );
};
