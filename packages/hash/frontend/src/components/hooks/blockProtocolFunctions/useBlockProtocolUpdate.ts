import { useMutation } from "@apollo/client";

import { BlockProtocolUpdateFn } from "../../../types/blockProtocol";
import { updateEntity } from "../../../graphql/queries/entity.queries";
import { useCallback } from "react";
import {
  UpdateEntityMutation,
  UpdateEntityMutationVariables,
} from "../../../graphql/autoGeneratedTypes";
import { apolloClient } from "../../../pages/_app";

export const useBlockProtocolUpdate = (): {
  update: BlockProtocolUpdateFn;
  updateLoading: boolean;
  updateError: any;
} => {
  // temporary hack to refetch page data after a mutation.
  // TODO: make caching of entities outside of GraphQL schema work
  // so that updates to those entities are reflected w/o doing this
  const onCompleted = () => apolloClient.reFetchObservableQueries();

  const [
    updateEntityFn,
    { loading: updateEntityLoading, error: updateEntityError },
  ] = useMutation<UpdateEntityMutation, UpdateEntityMutationVariables>(
    updateEntity,
    { onCompleted }
  );

  const [updatePageFn, { loading: updatePageLoading, error: updatePageError }] =
    useMutation<UpdateEntityMutation, UpdateEntityMutationVariables>(
      updateEntity,
      { onCompleted }
    );

  const update: BlockProtocolUpdateFn = useCallback((actions) => {
    for (const action of actions) {
      (action.entityType === "Page" ? updatePageFn : updateEntityFn)({
        variables: {
          id: action.entityId,
          properties: action.data,
        },
      });
    }
  }, []);

  const updateLoading = updateEntityLoading || updatePageLoading;
  const updateError = updateEntityError ?? updatePageError;

  return {
    update,
    updateLoading,
    updateError,
  };
};
