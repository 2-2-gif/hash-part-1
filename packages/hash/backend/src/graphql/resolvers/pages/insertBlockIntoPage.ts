import { ApolloError } from "apollo-server-express";

import { genId } from "../../../util";
import { DbPage } from "../../../types/dbTypes";
import {
  MutationInsertBlockIntoPageArgs,
  Resolver,
  Visibility,
} from "../../autoGeneratedTypes";
import { GraphQLContext } from "../../context";

export const insertBlockIntoPage: Resolver<
  Promise<DbPage>,
  {},
  GraphQLContext,
  MutationInsertBlockIntoPageArgs
> = async (
  _,
  {
    componentId,
    entityId,
    entityProperties,
    entityType,
    accountId,
    pageId,
    position,
    versioned = false,
  },
  { dataSources }
) => {
  let entity;
  if (entityId) {
    // Update
    entity = await dataSources.db.getEntity({ accountId, entityId });
    if (!entity) {
      throw new ApolloError(`entity ${entityId} not found`, "NOT_FOUND");
    }
  } else if (entityProperties && entityType) {
    // Create new entity
    entity = await dataSources.db.createEntity({
      accountId,
      createdById: genId(), // TODO
      type: entityType,
      properties: entityProperties,
      versioned,
    });
  } else {
    throw new Error(
      `One of entityId OR entityProperties and entityType must be provided`
    );
  }

  const blockProperties = {
    componentId,
    entityType: entity.type,
    entityId: entity.entityId,
    accountId: entity.accountId,
  };

  const newBlock = await dataSources.db.createEntity({
    accountId,
    type: "Block",
    createdById: genId(), // TODO
    properties: blockProperties,
    versioned,
  });

  // Get and update the page. We need to perform this within the same
  // transaction to prevent conflicts.
  const updatedEntities = await dataSources.db.getAndUpdateEntity({
    accountId,
    entityId: pageId,
    handler: (page) => {
      if (position > page.properties.contents.length) {
        position = page.properties.contents.length;
      }

      page.properties.contents = [
        ...page.properties.contents.slice(0, position),
        {
          type: "Block",
          entityId: newBlock.entityId,
          accountId: newBlock.accountId,
        },
        ...page.properties.contents.slice(position),
      ];

      return page;
    },
  });

  // TODO: for now, all entities are non-versioned, so the list array only have a single
  // element. Return when versioned entities are implemented at the API layer.
  return {
    ...updatedEntities[0],
    id: updatedEntities[0].entityId,
    accountId: updatedEntities[0].accountId,
    visibility: Visibility.Public, // TODO: get from entity metadata
  } as DbPage;
};
