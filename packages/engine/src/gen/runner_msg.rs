#![allow(
    clippy::module_name_repetitions,
    clippy::must_use_candidate,
    clippy::cast_sign_loss,
    clippy::empty_enum,
    clippy::used_underscore_binding,
    clippy::redundant_static_lifetimes,
    clippy::redundant_field_names,
    clippy::unused_imports,
    unused_imports
)]
// automatically generated by the FlatBuffers compiler, do not modify

use super::batch::*;
use super::metaversion::*;
use super::runner_error::*;
use super::runner_errors::*;
use super::runner_warning::*;
use super::runner_warnings::*;
use super::serialized::*;
use super::sync_context::*;
use super::sync_state::*;
use super::sync_state_interim::*;
use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TASK_MSG_PAYLOAD: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TASK_MSG_PAYLOAD: u8 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TASK_MSG_PAYLOAD: [TaskMsgPayload; 8] = [
    TaskMsgPayload::NONE,
    TaskMsgPayload::Serialized,
    TaskMsgPayload::BehaviorExecution,
    TaskMsgPayload::BehaviorExecutionBehaviorErrors,
    TaskMsgPayload::BehaviorExecutionWarnings,
    TaskMsgPayload::RunInitializer,
    TaskMsgPayload::InitializerError,
    TaskMsgPayload::InitializerCompleted,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TaskMsgPayload(pub u8);
#[allow(non_upper_case_globals)]
impl TaskMsgPayload {
    pub const NONE: Self = Self(0);
    pub const Serialized: Self = Self(1);
    pub const BehaviorExecution: Self = Self(2);
    pub const BehaviorExecutionBehaviorErrors: Self = Self(3);
    pub const BehaviorExecutionWarnings: Self = Self(4);
    pub const RunInitializer: Self = Self(5);
    pub const InitializerError: Self = Self(6);
    pub const InitializerCompleted: Self = Self(7);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::Serialized,
        Self::BehaviorExecution,
        Self::BehaviorExecutionBehaviorErrors,
        Self::BehaviorExecutionWarnings,
        Self::RunInitializer,
        Self::InitializerError,
        Self::InitializerCompleted,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::Serialized => Some("Serialized"),
            Self::BehaviorExecution => Some("BehaviorExecution"),
            Self::BehaviorExecutionBehaviorErrors => Some("BehaviorExecutionBehaviorErrors"),
            Self::BehaviorExecutionWarnings => Some("BehaviorExecutionWarnings"),
            Self::RunInitializer => Some("RunInitializer"),
            Self::InitializerError => Some("InitializerError"),
            Self::InitializerCompleted => Some("InitializerCompleted"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for TaskMsgPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for TaskMsgPayload {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for TaskMsgPayload {
    type Output = TaskMsgPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for TaskMsgPayload {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for TaskMsgPayload {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for TaskMsgPayload {}
pub struct TaskMsgPayloadUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RUNNER_MSG_PAYLOAD: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RUNNER_MSG_PAYLOAD: u8 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RUNNER_MSG_PAYLOAD: [RunnerMsgPayload; 11] = [
    RunnerMsgPayload::NONE,
    RunnerMsgPayload::TaskMsg,
    RunnerMsgPayload::StateSync,
    RunnerMsgPayload::ContextSync,
    RunnerMsgPayload::StateInterimSync,
    RunnerMsgPayload::KillRunner,
    RunnerMsgPayload::TerminateSimulationRun,
    RunnerMsgPayload::RunnerError,
    RunnerMsgPayload::RunnerErrors,
    RunnerMsgPayload::RunnerWarning,
    RunnerMsgPayload::RunnerWarnings,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RunnerMsgPayload(pub u8);
#[allow(non_upper_case_globals)]
impl RunnerMsgPayload {
    pub const NONE: Self = Self(0);
    pub const TaskMsg: Self = Self(1);
    pub const StateSync: Self = Self(2);
    pub const ContextSync: Self = Self(3);
    pub const StateInterimSync: Self = Self(4);
    pub const KillRunner: Self = Self(5);
    pub const TerminateSimulationRun: Self = Self(6);
    pub const RunnerError: Self = Self(7);
    pub const RunnerErrors: Self = Self(8);
    pub const RunnerWarning: Self = Self(9);
    pub const RunnerWarnings: Self = Self(10);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TaskMsg,
        Self::StateSync,
        Self::ContextSync,
        Self::StateInterimSync,
        Self::KillRunner,
        Self::TerminateSimulationRun,
        Self::RunnerError,
        Self::RunnerErrors,
        Self::RunnerWarning,
        Self::RunnerWarnings,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TaskMsg => Some("TaskMsg"),
            Self::StateSync => Some("StateSync"),
            Self::ContextSync => Some("ContextSync"),
            Self::StateInterimSync => Some("StateInterimSync"),
            Self::KillRunner => Some("KillRunner"),
            Self::TerminateSimulationRun => Some("TerminateSimulationRun"),
            Self::RunnerError => Some("RunnerError"),
            Self::RunnerErrors => Some("RunnerErrors"),
            Self::RunnerWarning => Some("RunnerWarning"),
            Self::RunnerWarnings => Some("RunnerWarnings"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for RunnerMsgPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for RunnerMsgPayload {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for RunnerMsgPayload {
    type Output = RunnerMsgPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for RunnerMsgPayload {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for RunnerMsgPayload {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for RunnerMsgPayload {}
pub struct RunnerMsgPayloadUnionTableOffset {}

// struct TaskID, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct TaskID(pub [u8; 16]);
impl Default for TaskID {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl std::fmt::Debug for TaskID {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("TaskID")
            .field("inner", &self.inner())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for TaskID {}
impl flatbuffers::SafeSliceAccess for TaskID {}
impl<'a> flatbuffers::Follow<'a> for TaskID {
    type Inner = &'a TaskID;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a TaskID>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a TaskID {
    type Inner = &'a TaskID;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<TaskID>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for TaskID {
    type Output = TaskID;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const TaskID as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b TaskID {
    type Output = TaskID;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const TaskID as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for TaskID {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}
impl<'a> TaskID {
    #[allow(clippy::too_many_arguments)]
    pub fn new(inner: &[i8; 16]) -> Self {
        let mut s = Self([0; 16]);
        s.set_inner(&inner);
        s
    }

    pub fn inner(&'a self) -> flatbuffers::Array<'a, i8, 16> {
        flatbuffers::Array::follow(&self.0, 0)
    }

    pub fn set_inner(&mut self, items: &[i8; 16]) {
        flatbuffers::emplace_scalar_array(&mut self.0, 0, items);
    }
}

pub enum KillRunnerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct KillRunner<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KillRunner<'a> {
    type Inner = KillRunner<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> KillRunner<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        KillRunner { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args KillRunnerArgs,
    ) -> flatbuffers::WIPOffset<KillRunner<'bldr>> {
        let mut builder = KillRunnerBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for KillRunner<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct KillRunnerArgs {}
impl<'a> Default for KillRunnerArgs {
    #[inline]
    fn default() -> Self {
        KillRunnerArgs {}
    }
}
pub struct KillRunnerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KillRunnerBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KillRunnerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        KillRunnerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<KillRunner<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for KillRunner<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("KillRunner");
        ds.finish()
    }
}
pub enum TerminateSimulationRunOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TerminateSimulationRun<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TerminateSimulationRun<'a> {
    type Inner = TerminateSimulationRun<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TerminateSimulationRun<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TerminateSimulationRun { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args TerminateSimulationRunArgs,
    ) -> flatbuffers::WIPOffset<TerminateSimulationRun<'bldr>> {
        let mut builder = TerminateSimulationRunBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for TerminateSimulationRun<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct TerminateSimulationRunArgs {}
impl<'a> Default for TerminateSimulationRunArgs {
    #[inline]
    fn default() -> Self {
        TerminateSimulationRunArgs {}
    }
}
pub struct TerminateSimulationRunBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TerminateSimulationRunBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> TerminateSimulationRunBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TerminateSimulationRunBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TerminateSimulationRun<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for TerminateSimulationRun<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("TerminateSimulationRun");
        ds.finish()
    }
}
pub enum BehaviorExecutionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BehaviorExecution<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BehaviorExecution<'a> {
    type Inner = BehaviorExecution<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BehaviorExecution<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BehaviorExecution { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args BehaviorExecutionArgs,
    ) -> flatbuffers::WIPOffset<BehaviorExecution<'bldr>> {
        let mut builder = BehaviorExecutionBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for BehaviorExecution<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct BehaviorExecutionArgs {}
impl<'a> Default for BehaviorExecutionArgs {
    #[inline]
    fn default() -> Self {
        BehaviorExecutionArgs {}
    }
}
pub struct BehaviorExecutionBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BehaviorExecutionBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BehaviorExecutionBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BehaviorExecutionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BehaviorExecution<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for BehaviorExecution<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("BehaviorExecution");
        ds.finish()
    }
}
pub enum BehaviorExecutionBehaviorErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BehaviorExecutionBehaviorError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BehaviorExecutionBehaviorError<'a> {
    type Inner = BehaviorExecutionBehaviorError<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BehaviorExecutionBehaviorError<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BehaviorExecutionBehaviorError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BehaviorExecutionBehaviorErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<BehaviorExecutionBehaviorError<'bldr>> {
        let mut builder = BehaviorExecutionBehaviorErrorBuilder::new(_fbb);
        if let Some(x) = args.full_msg {
            builder.add_full_msg(x);
        }
        if let Some(x) = args.short_msg {
            builder.add_short_msg(x);
        }
        if let Some(x) = args.behavior_name {
            builder.add_behavior_name(x);
        }
        builder.finish()
    }

    pub const VT_BEHAVIOR_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SHORT_MSG: flatbuffers::VOffsetT = 6;
    pub const VT_FULL_MSG: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn behavior_name(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            BehaviorExecutionBehaviorError::VT_BEHAVIOR_NAME,
            None,
        )
    }
    #[inline]
    pub fn short_msg(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            BehaviorExecutionBehaviorError::VT_SHORT_MSG,
            None,
        )
    }
    #[inline]
    pub fn full_msg(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            BehaviorExecutionBehaviorError::VT_FULL_MSG,
            None,
        )
    }
}

impl flatbuffers::Verifiable for BehaviorExecutionBehaviorError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"behavior_name",
                Self::VT_BEHAVIOR_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"short_msg",
                Self::VT_SHORT_MSG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"full_msg",
                Self::VT_FULL_MSG,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct BehaviorExecutionBehaviorErrorArgs<'a> {
    pub behavior_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub short_msg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub full_msg: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BehaviorExecutionBehaviorErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        BehaviorExecutionBehaviorErrorArgs {
            behavior_name: None,
            short_msg: None,
            full_msg: None,
        }
    }
}
pub struct BehaviorExecutionBehaviorErrorBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BehaviorExecutionBehaviorErrorBuilder<'a, 'b> {
    #[inline]
    pub fn add_behavior_name(&mut self, behavior_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionBehaviorError::VT_BEHAVIOR_NAME,
            behavior_name,
        );
    }
    #[inline]
    pub fn add_short_msg(&mut self, short_msg: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionBehaviorError::VT_SHORT_MSG,
            short_msg,
        );
    }
    #[inline]
    pub fn add_full_msg(&mut self, full_msg: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionBehaviorError::VT_FULL_MSG,
            full_msg,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BehaviorExecutionBehaviorErrorBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BehaviorExecutionBehaviorErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BehaviorExecutionBehaviorError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for BehaviorExecutionBehaviorError<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("BehaviorExecutionBehaviorError");
        ds.field("behavior_name", &self.behavior_name());
        ds.field("short_msg", &self.short_msg());
        ds.field("full_msg", &self.full_msg());
        ds.finish()
    }
}
pub enum BehaviorExecutionBehaviorErrorsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BehaviorExecutionBehaviorErrors<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BehaviorExecutionBehaviorErrors<'a> {
    type Inner = BehaviorExecutionBehaviorErrors<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BehaviorExecutionBehaviorErrors<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BehaviorExecutionBehaviorErrors { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BehaviorExecutionBehaviorErrorsArgs<'args>,
    ) -> flatbuffers::WIPOffset<BehaviorExecutionBehaviorErrors<'bldr>> {
        let mut builder = BehaviorExecutionBehaviorErrorsBuilder::new(_fbb);
        if let Some(x) = args.inner {
            builder.add_inner(x);
        }
        builder.finish()
    }

    pub const VT_INNER: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn inner(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BehaviorExecutionBehaviorError<'a>>>,
    > {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BehaviorExecutionBehaviorError>>,
        >>(BehaviorExecutionBehaviorErrors::VT_INNER, None)
    }
}

impl flatbuffers::Verifiable for BehaviorExecutionBehaviorErrors<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<BehaviorExecutionBehaviorError>,
                >,
            >>(&"inner", Self::VT_INNER, false)?
            .finish();
        Ok(())
    }
}
pub struct BehaviorExecutionBehaviorErrorsArgs<'a> {
    pub inner: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<BehaviorExecutionBehaviorError<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for BehaviorExecutionBehaviorErrorsArgs<'a> {
    #[inline]
    fn default() -> Self {
        BehaviorExecutionBehaviorErrorsArgs { inner: None }
    }
}
pub struct BehaviorExecutionBehaviorErrorsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BehaviorExecutionBehaviorErrorsBuilder<'a, 'b> {
    #[inline]
    pub fn add_inner(
        &mut self,
        inner: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<BehaviorExecutionBehaviorError<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionBehaviorErrors::VT_INNER,
            inner,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BehaviorExecutionBehaviorErrorsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BehaviorExecutionBehaviorErrorsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BehaviorExecutionBehaviorErrors<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for BehaviorExecutionBehaviorErrors<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("BehaviorExecutionBehaviorErrors");
        ds.field("inner", &self.inner());
        ds.finish()
    }
}
pub enum BehaviorExecutionWarningOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BehaviorExecutionWarning<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BehaviorExecutionWarning<'a> {
    type Inner = BehaviorExecutionWarning<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BehaviorExecutionWarning<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BehaviorExecutionWarning { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BehaviorExecutionWarningArgs<'args>,
    ) -> flatbuffers::WIPOffset<BehaviorExecutionWarning<'bldr>> {
        let mut builder = BehaviorExecutionWarningBuilder::new(_fbb);
        builder.add_line_number(args.line_number);
        if let Some(x) = args.file_name {
            builder.add_file_name(x);
        }
        if let Some(x) = args.details {
            builder.add_details(x);
        }
        if let Some(x) = args.msg {
            builder.add_msg(x);
        }
        builder.finish()
    }

    pub const VT_MSG: flatbuffers::VOffsetT = 4;
    pub const VT_DETAILS: flatbuffers::VOffsetT = 6;
    pub const VT_FILE_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_LINE_NUMBER: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn msg(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(BehaviorExecutionWarning::VT_MSG, None)
            .unwrap()
    }
    #[inline]
    pub fn details(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(BehaviorExecutionWarning::VT_DETAILS, None)
    }
    #[inline]
    pub fn file_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(BehaviorExecutionWarning::VT_FILE_NAME, None)
    }
    #[inline]
    pub fn line_number(&self) -> i32 {
        self._tab
            .get::<i32>(BehaviorExecutionWarning::VT_LINE_NUMBER, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for BehaviorExecutionWarning<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"msg", Self::VT_MSG, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"details", Self::VT_DETAILS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"file_name",
                Self::VT_FILE_NAME,
                false,
            )?
            .visit_field::<i32>(&"line_number", Self::VT_LINE_NUMBER, false)?
            .finish();
        Ok(())
    }
}
pub struct BehaviorExecutionWarningArgs<'a> {
    pub msg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub details: Option<flatbuffers::WIPOffset<&'a str>>,
    pub file_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub line_number: i32,
}
impl<'a> Default for BehaviorExecutionWarningArgs<'a> {
    #[inline]
    fn default() -> Self {
        BehaviorExecutionWarningArgs {
            msg: None, // required field
            details: None,
            file_name: None,
            line_number: 0,
        }
    }
}
pub struct BehaviorExecutionWarningBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BehaviorExecutionWarningBuilder<'a, 'b> {
    #[inline]
    pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BehaviorExecutionWarning::VT_MSG, msg);
    }
    #[inline]
    pub fn add_details(&mut self, details: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionWarning::VT_DETAILS,
            details,
        );
    }
    #[inline]
    pub fn add_file_name(&mut self, file_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionWarning::VT_FILE_NAME,
            file_name,
        );
    }
    #[inline]
    pub fn add_line_number(&mut self, line_number: i32) {
        self.fbb_
            .push_slot::<i32>(BehaviorExecutionWarning::VT_LINE_NUMBER, line_number, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BehaviorExecutionWarningBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BehaviorExecutionWarningBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BehaviorExecutionWarning<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, BehaviorExecutionWarning::VT_MSG, "msg");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for BehaviorExecutionWarning<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("BehaviorExecutionWarning");
        ds.field("msg", &self.msg());
        ds.field("details", &self.details());
        ds.field("file_name", &self.file_name());
        ds.field("line_number", &self.line_number());
        ds.finish()
    }
}
pub enum BehaviorExecutionWarningsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BehaviorExecutionWarnings<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BehaviorExecutionWarnings<'a> {
    type Inner = BehaviorExecutionWarnings<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BehaviorExecutionWarnings<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BehaviorExecutionWarnings { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BehaviorExecutionWarningsArgs<'args>,
    ) -> flatbuffers::WIPOffset<BehaviorExecutionWarnings<'bldr>> {
        let mut builder = BehaviorExecutionWarningsBuilder::new(_fbb);
        if let Some(x) = args.inner {
            builder.add_inner(x);
        }
        builder.finish()
    }

    pub const VT_INNER: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn inner(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BehaviorExecutionWarning<'a>>>>
    {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BehaviorExecutionWarning>>,
        >>(BehaviorExecutionWarnings::VT_INNER, None)
    }
}

impl flatbuffers::Verifiable for BehaviorExecutionWarnings<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BehaviorExecutionWarning>>,
            >>(&"inner", Self::VT_INNER, false)?
            .finish();
        Ok(())
    }
}
pub struct BehaviorExecutionWarningsArgs<'a> {
    pub inner: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BehaviorExecutionWarning<'a>>>,
        >,
    >,
}
impl<'a> Default for BehaviorExecutionWarningsArgs<'a> {
    #[inline]
    fn default() -> Self {
        BehaviorExecutionWarningsArgs { inner: None }
    }
}
pub struct BehaviorExecutionWarningsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BehaviorExecutionWarningsBuilder<'a, 'b> {
    #[inline]
    pub fn add_inner(
        &mut self,
        inner: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BehaviorExecutionWarning<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BehaviorExecutionWarnings::VT_INNER,
            inner,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BehaviorExecutionWarningsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BehaviorExecutionWarningsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BehaviorExecutionWarnings<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for BehaviorExecutionWarnings<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("BehaviorExecutionWarnings");
        ds.field("inner", &self.inner());
        ds.finish()
    }
}
pub enum RunInitializerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RunInitializer<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunInitializer<'a> {
    type Inner = RunInitializer<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> RunInitializer<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RunInitializer { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RunInitializerArgs<'args>,
    ) -> flatbuffers::WIPOffset<RunInitializer<'bldr>> {
        let mut builder = RunInitializerBuilder::new(_fbb);
        if let Some(x) = args.properties {
            builder.add_properties(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.src {
            builder.add_src(x);
        }
        builder.finish()
    }

    pub const VT_SRC: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn src(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RunInitializer::VT_SRC, None)
            .unwrap()
    }
    #[inline]
    pub fn name(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RunInitializer::VT_NAME, None)
            .unwrap()
    }
    #[inline]
    pub fn properties(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(RunInitializer::VT_PROPERTIES, None)
            .unwrap()
    }
}

impl flatbuffers::Verifiable for RunInitializer<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"src", Self::VT_SRC, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"properties",
                Self::VT_PROPERTIES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct RunInitializerArgs<'a> {
    pub src: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RunInitializerArgs<'a> {
    #[inline]
    fn default() -> Self {
        RunInitializerArgs {
            src: None,        // required field
            name: None,       // required field
            properties: None, // required field
        }
    }
}
pub struct RunInitializerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunInitializerBuilder<'a, 'b> {
    #[inline]
    pub fn add_src(&mut self, src: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RunInitializer::VT_SRC, src);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RunInitializer::VT_NAME, name);
    }
    #[inline]
    pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RunInitializer::VT_PROPERTIES,
            properties,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RunInitializerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RunInitializerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RunInitializer<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, RunInitializer::VT_SRC, "src");
        self.fbb_.required(o, RunInitializer::VT_NAME, "name");
        self.fbb_
            .required(o, RunInitializer::VT_PROPERTIES, "properties");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for RunInitializer<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("RunInitializer");
        ds.field("src", &self.src());
        ds.field("name", &self.name());
        ds.field("properties", &self.properties());
        ds.finish()
    }
}
pub enum InitializerErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InitializerError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InitializerError<'a> {
    type Inner = InitializerError<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> InitializerError<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InitializerError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InitializerErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<InitializerError<'bldr>> {
        let mut builder = InitializerErrorBuilder::new(_fbb);
        if let Some(x) = args.full_msg {
            builder.add_full_msg(x);
        }
        if let Some(x) = args.short_msg {
            builder.add_short_msg(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SHORT_MSG: flatbuffers::VOffsetT = 6;
    pub const VT_FULL_MSG: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn name(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InitializerError::VT_NAME, None)
            .unwrap()
    }
    #[inline]
    pub fn short_msg(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InitializerError::VT_SHORT_MSG, None)
            .unwrap()
    }
    #[inline]
    pub fn full_msg(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InitializerError::VT_FULL_MSG, None)
            .unwrap()
    }
}

impl flatbuffers::Verifiable for InitializerError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"short_msg",
                Self::VT_SHORT_MSG,
                true,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                &"full_msg",
                Self::VT_FULL_MSG,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct InitializerErrorArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub short_msg: Option<flatbuffers::WIPOffset<&'a str>>,
    pub full_msg: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for InitializerErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        InitializerErrorArgs {
            name: None,      // required field
            short_msg: None, // required field
            full_msg: None,  // required field
        }
    }
}
pub struct InitializerErrorBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InitializerErrorBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InitializerError::VT_NAME, name);
    }
    #[inline]
    pub fn add_short_msg(&mut self, short_msg: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            InitializerError::VT_SHORT_MSG,
            short_msg,
        );
    }
    #[inline]
    pub fn add_full_msg(&mut self, full_msg: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InitializerError::VT_FULL_MSG, full_msg);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> InitializerErrorBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InitializerErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InitializerError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, InitializerError::VT_NAME, "name");
        self.fbb_
            .required(o, InitializerError::VT_SHORT_MSG, "short_msg");
        self.fbb_
            .required(o, InitializerError::VT_FULL_MSG, "full_msg");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for InitializerError<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("InitializerError");
        ds.field("name", &self.name());
        ds.field("short_msg", &self.short_msg());
        ds.field("full_msg", &self.full_msg());
        ds.finish()
    }
}
pub enum InitializerCompletedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct InitializerCompleted<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InitializerCompleted<'a> {
    type Inner = InitializerCompleted<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> InitializerCompleted<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InitializerCompleted { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InitializerCompletedArgs<'args>,
    ) -> flatbuffers::WIPOffset<InitializerCompleted<'bldr>> {
        let mut builder = InitializerCompletedBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn name(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InitializerCompleted::VT_NAME, None)
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> &'a str {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InitializerCompleted::VT_DATA, None)
            .unwrap()
    }
}

impl flatbuffers::Verifiable for InitializerCompleted<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"data", Self::VT_DATA, true)?
            .finish();
        Ok(())
    }
}
pub struct InitializerCompletedArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for InitializerCompletedArgs<'a> {
    #[inline]
    fn default() -> Self {
        InitializerCompletedArgs {
            name: None, // required field
            data: None, // required field
        }
    }
}
pub struct InitializerCompletedBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InitializerCompletedBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InitializerCompleted::VT_NAME, name);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InitializerCompleted::VT_DATA, data);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> InitializerCompletedBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InitializerCompletedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InitializerCompleted<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, InitializerCompleted::VT_NAME, "name");
        self.fbb_.required(o, InitializerCompleted::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for InitializerCompleted<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("InitializerCompleted");
        ds.field("name", &self.name());
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum TaskMsgOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TaskMsg<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TaskMsg<'a> {
    type Inner = TaskMsg<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TaskMsg<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TaskMsg { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TaskMsgArgs<'args>,
    ) -> flatbuffers::WIPOffset<TaskMsg<'bldr>> {
        let mut builder = TaskMsgBuilder::new(_fbb);
        if let Some(x) = args.payload {
            builder.add_payload(x);
        }
        if let Some(x) = args.metaversioning {
            builder.add_metaversioning(x);
        }
        if let Some(x) = args.task_id {
            builder.add_task_id(x);
        }
        builder.add_package_sid(args.package_sid);
        builder.add_payload_type(args.payload_type);
        builder.finish()
    }

    pub const VT_PACKAGE_SID: flatbuffers::VOffsetT = 4;
    pub const VT_TASK_ID: flatbuffers::VOffsetT = 6;
    pub const VT_METAVERSIONING: flatbuffers::VOffsetT = 8;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn package_sid(&self) -> u16 {
        self._tab
            .get::<u16>(TaskMsg::VT_PACKAGE_SID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn task_id(&self) -> Option<&'a TaskID> {
        self._tab.get::<TaskID>(TaskMsg::VT_TASK_ID, None)
    }
    #[inline]
    pub fn metaversioning(&self) -> Option<StateInterimSync<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<StateInterimSync>>(TaskMsg::VT_METAVERSIONING, None)
    }
    #[inline]
    pub fn payload_type(&self) -> TaskMsgPayload {
        self._tab
            .get::<TaskMsgPayload>(TaskMsg::VT_PAYLOAD_TYPE, Some(TaskMsgPayload::NONE))
            .unwrap()
    }
    #[inline]
    pub fn payload(&self) -> flatbuffers::Table<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(TaskMsg::VT_PAYLOAD, None)
            .unwrap()
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_serialized(&self) -> Option<Serialized<'a>> {
        if self.payload_type() == TaskMsgPayload::Serialized {
            let u = self.payload();
            Some(Serialized::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_behavior_execution(&self) -> Option<BehaviorExecution<'a>> {
        if self.payload_type() == TaskMsgPayload::BehaviorExecution {
            let u = self.payload();
            Some(BehaviorExecution::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_behavior_execution_behavior_errors(
        &self,
    ) -> Option<BehaviorExecutionBehaviorErrors<'a>> {
        if self.payload_type() == TaskMsgPayload::BehaviorExecutionBehaviorErrors {
            let u = self.payload();
            Some(BehaviorExecutionBehaviorErrors::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_behavior_execution_warnings(&self) -> Option<BehaviorExecutionWarnings<'a>> {
        if self.payload_type() == TaskMsgPayload::BehaviorExecutionWarnings {
            let u = self.payload();
            Some(BehaviorExecutionWarnings::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_run_initializer(&self) -> Option<RunInitializer<'a>> {
        if self.payload_type() == TaskMsgPayload::RunInitializer {
            let u = self.payload();
            Some(RunInitializer::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_initializer_error(&self) -> Option<InitializerError<'a>> {
        if self.payload_type() == TaskMsgPayload::InitializerError {
            let u = self.payload();
            Some(InitializerError::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_initializer_completed(&self) -> Option<InitializerCompleted<'a>> {
        if self.payload_type() == TaskMsgPayload::InitializerCompleted {
            let u = self.payload();
            Some(InitializerCompleted::init_from_table(u))
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for TaskMsg<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<u16>(&"package_sid", Self::VT_PACKAGE_SID, false)?
     .visit_field::<TaskID>(&"task_id", Self::VT_TASK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StateInterimSync>>(&"metaversioning", Self::VT_METAVERSIONING, false)?
     .visit_union::<TaskMsgPayload, _>(&"payload_type", Self::VT_PAYLOAD_TYPE, &"payload", Self::VT_PAYLOAD, true, |key, v, pos| {
        match key {
          TaskMsgPayload::Serialized => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Serialized>>("TaskMsgPayload::Serialized", pos),
          TaskMsgPayload::BehaviorExecution => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BehaviorExecution>>("TaskMsgPayload::BehaviorExecution", pos),
          TaskMsgPayload::BehaviorExecutionBehaviorErrors => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BehaviorExecutionBehaviorErrors>>("TaskMsgPayload::BehaviorExecutionBehaviorErrors", pos),
          TaskMsgPayload::BehaviorExecutionWarnings => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BehaviorExecutionWarnings>>("TaskMsgPayload::BehaviorExecutionWarnings", pos),
          TaskMsgPayload::RunInitializer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunInitializer>>("TaskMsgPayload::RunInitializer", pos),
          TaskMsgPayload::InitializerError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InitializerError>>("TaskMsgPayload::InitializerError", pos),
          TaskMsgPayload::InitializerCompleted => v.verify_union_variant::<flatbuffers::ForwardsUOffset<InitializerCompleted>>("TaskMsgPayload::InitializerCompleted", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct TaskMsgArgs<'a> {
    pub package_sid: u16,
    pub task_id: Option<&'a TaskID>,
    pub metaversioning: Option<flatbuffers::WIPOffset<StateInterimSync<'a>>>,
    pub payload_type: TaskMsgPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for TaskMsgArgs<'a> {
    #[inline]
    fn default() -> Self {
        TaskMsgArgs {
            package_sid: 0,
            task_id: None,
            metaversioning: None,
            payload_type: TaskMsgPayload::NONE,
            payload: None, // required field
        }
    }
}
pub struct TaskMsgBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TaskMsgBuilder<'a, 'b> {
    #[inline]
    pub fn add_package_sid(&mut self, package_sid: u16) {
        self.fbb_
            .push_slot::<u16>(TaskMsg::VT_PACKAGE_SID, package_sid, 0);
    }
    #[inline]
    pub fn add_task_id(&mut self, task_id: &TaskID) {
        self.fbb_
            .push_slot_always::<&TaskID>(TaskMsg::VT_TASK_ID, task_id);
    }
    #[inline]
    pub fn add_metaversioning(
        &mut self,
        metaversioning: flatbuffers::WIPOffset<StateInterimSync<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<StateInterimSync>>(
                TaskMsg::VT_METAVERSIONING,
                metaversioning,
            );
    }
    #[inline]
    pub fn add_payload_type(&mut self, payload_type: TaskMsgPayload) {
        self.fbb_.push_slot::<TaskMsgPayload>(
            TaskMsg::VT_PAYLOAD_TYPE,
            payload_type,
            TaskMsgPayload::NONE,
        );
    }
    #[inline]
    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TaskMsg::VT_PAYLOAD, payload);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TaskMsgBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TaskMsgBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TaskMsg<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, TaskMsg::VT_PAYLOAD, "payload");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for TaskMsg<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("TaskMsg");
        ds.field("package_sid", &self.package_sid());
        ds.field("task_id", &self.task_id());
        ds.field("metaversioning", &self.metaversioning());
        ds.field("payload_type", &self.payload_type());
        match self.payload_type() {
            TaskMsgPayload::Serialized => {
                if let Some(x) = self.payload_as_serialized() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TaskMsgPayload::BehaviorExecution => {
                if let Some(x) = self.payload_as_behavior_execution() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TaskMsgPayload::BehaviorExecutionBehaviorErrors => {
                if let Some(x) = self.payload_as_behavior_execution_behavior_errors() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TaskMsgPayload::BehaviorExecutionWarnings => {
                if let Some(x) = self.payload_as_behavior_execution_warnings() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TaskMsgPayload::RunInitializer => {
                if let Some(x) = self.payload_as_run_initializer() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TaskMsgPayload::InitializerError => {
                if let Some(x) = self.payload_as_initializer_error() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TaskMsgPayload::InitializerCompleted => {
                if let Some(x) = self.payload_as_initializer_completed() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("payload", &x)
            }
        };
        ds.finish()
    }
}
pub enum RunnerMsgOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RunnerMsg<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RunnerMsg<'a> {
    type Inner = RunnerMsg<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> RunnerMsg<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RunnerMsg { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RunnerMsgArgs,
    ) -> flatbuffers::WIPOffset<RunnerMsg<'bldr>> {
        let mut builder = RunnerMsgBuilder::new(_fbb);
        if let Some(x) = args.payload {
            builder.add_payload(x);
        }
        builder.add_sim_sid(args.sim_sid);
        builder.add_payload_type(args.payload_type);
        builder.finish()
    }

    pub const VT_SIM_SID: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn sim_sid(&self) -> u32 {
        self._tab
            .get::<u32>(RunnerMsg::VT_SIM_SID, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn payload_type(&self) -> RunnerMsgPayload {
        self._tab
            .get::<RunnerMsgPayload>(RunnerMsg::VT_PAYLOAD_TYPE, Some(RunnerMsgPayload::NONE))
            .unwrap()
    }
    #[inline]
    pub fn payload(&self) -> flatbuffers::Table<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                RunnerMsg::VT_PAYLOAD,
                None,
            )
            .unwrap()
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_task_msg(&self) -> Option<TaskMsg<'a>> {
        if self.payload_type() == RunnerMsgPayload::TaskMsg {
            let u = self.payload();
            Some(TaskMsg::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_state_sync(&self) -> Option<StateSync<'a>> {
        if self.payload_type() == RunnerMsgPayload::StateSync {
            let u = self.payload();
            Some(StateSync::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_context_sync(&self) -> Option<ContextSync<'a>> {
        if self.payload_type() == RunnerMsgPayload::ContextSync {
            let u = self.payload();
            Some(ContextSync::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_state_interim_sync(&self) -> Option<StateInterimSync<'a>> {
        if self.payload_type() == RunnerMsgPayload::StateInterimSync {
            let u = self.payload();
            Some(StateInterimSync::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_kill_runner(&self) -> Option<KillRunner<'a>> {
        if self.payload_type() == RunnerMsgPayload::KillRunner {
            let u = self.payload();
            Some(KillRunner::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_terminate_simulation_run(&self) -> Option<TerminateSimulationRun<'a>> {
        if self.payload_type() == RunnerMsgPayload::TerminateSimulationRun {
            let u = self.payload();
            Some(TerminateSimulationRun::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_runner_error(&self) -> Option<RunnerError<'a>> {
        if self.payload_type() == RunnerMsgPayload::RunnerError {
            let u = self.payload();
            Some(RunnerError::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_runner_errors(&self) -> Option<RunnerErrors<'a>> {
        if self.payload_type() == RunnerMsgPayload::RunnerErrors {
            let u = self.payload();
            Some(RunnerErrors::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_runner_warning(&self) -> Option<RunnerWarning<'a>> {
        if self.payload_type() == RunnerMsgPayload::RunnerWarning {
            let u = self.payload();
            Some(RunnerWarning::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn payload_as_runner_warnings(&self) -> Option<RunnerWarnings<'a>> {
        if self.payload_type() == RunnerMsgPayload::RunnerWarnings {
            let u = self.payload();
            Some(RunnerWarnings::init_from_table(u))
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for RunnerMsg<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<u32>(&"sim_sid", Self::VT_SIM_SID, false)?
     .visit_union::<RunnerMsgPayload, _>(&"payload_type", Self::VT_PAYLOAD_TYPE, &"payload", Self::VT_PAYLOAD, true, |key, v, pos| {
        match key {
          RunnerMsgPayload::TaskMsg => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TaskMsg>>("RunnerMsgPayload::TaskMsg", pos),
          RunnerMsgPayload::StateSync => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StateSync>>("RunnerMsgPayload::StateSync", pos),
          RunnerMsgPayload::ContextSync => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ContextSync>>("RunnerMsgPayload::ContextSync", pos),
          RunnerMsgPayload::StateInterimSync => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StateInterimSync>>("RunnerMsgPayload::StateInterimSync", pos),
          RunnerMsgPayload::KillRunner => v.verify_union_variant::<flatbuffers::ForwardsUOffset<KillRunner>>("RunnerMsgPayload::KillRunner", pos),
          RunnerMsgPayload::TerminateSimulationRun => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TerminateSimulationRun>>("RunnerMsgPayload::TerminateSimulationRun", pos),
          RunnerMsgPayload::RunnerError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunnerError>>("RunnerMsgPayload::RunnerError", pos),
          RunnerMsgPayload::RunnerErrors => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunnerErrors>>("RunnerMsgPayload::RunnerErrors", pos),
          RunnerMsgPayload::RunnerWarning => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunnerWarning>>("RunnerMsgPayload::RunnerWarning", pos),
          RunnerMsgPayload::RunnerWarnings => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RunnerWarnings>>("RunnerMsgPayload::RunnerWarnings", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct RunnerMsgArgs {
    pub sim_sid: u32,
    pub payload_type: RunnerMsgPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RunnerMsgArgs {
    #[inline]
    fn default() -> Self {
        RunnerMsgArgs {
            sim_sid: 0,
            payload_type: RunnerMsgPayload::NONE,
            payload: None, // required field
        }
    }
}
pub struct RunnerMsgBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RunnerMsgBuilder<'a, 'b> {
    #[inline]
    pub fn add_sim_sid(&mut self, sim_sid: u32) {
        self.fbb_
            .push_slot::<u32>(RunnerMsg::VT_SIM_SID, sim_sid, 0);
    }
    #[inline]
    pub fn add_payload_type(&mut self, payload_type: RunnerMsgPayload) {
        self.fbb_.push_slot::<RunnerMsgPayload>(
            RunnerMsg::VT_PAYLOAD_TYPE,
            payload_type,
            RunnerMsgPayload::NONE,
        );
    }
    #[inline]
    pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RunnerMsg::VT_PAYLOAD, payload);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RunnerMsgBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RunnerMsgBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RunnerMsg<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, RunnerMsg::VT_PAYLOAD, "payload");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for RunnerMsg<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("RunnerMsg");
        ds.field("sim_sid", &self.sim_sid());
        ds.field("payload_type", &self.payload_type());
        match self.payload_type() {
            RunnerMsgPayload::TaskMsg => {
                if let Some(x) = self.payload_as_task_msg() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::StateSync => {
                if let Some(x) = self.payload_as_state_sync() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::ContextSync => {
                if let Some(x) = self.payload_as_context_sync() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::StateInterimSync => {
                if let Some(x) = self.payload_as_state_interim_sync() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::KillRunner => {
                if let Some(x) = self.payload_as_kill_runner() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::TerminateSimulationRun => {
                if let Some(x) = self.payload_as_terminate_simulation_run() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::RunnerError => {
                if let Some(x) = self.payload_as_runner_error() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::RunnerErrors => {
                if let Some(x) = self.payload_as_runner_errors() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::RunnerWarning => {
                if let Some(x) = self.payload_as_runner_warning() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RunnerMsgPayload::RunnerWarnings => {
                if let Some(x) = self.payload_as_runner_warnings() {
                    ds.field("payload", &x)
                } else {
                    ds.field(
                        "payload",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("payload", &x)
            }
        };
        ds.finish()
    }
}
#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_runner_msg<'a>(buf: &'a [u8]) -> RunnerMsg<'a> {
    unsafe { flatbuffers::root_unchecked::<RunnerMsg<'a>>(buf) }
}

#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_runner_msg<'a>(buf: &'a [u8]) -> RunnerMsg<'a> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<RunnerMsg<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `RunnerMsg`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_runner_msg_unchecked`.
pub fn root_as_runner_msg(buf: &[u8]) -> Result<RunnerMsg, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<RunnerMsg>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RunnerMsg` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_runner_msg_unchecked`.
pub fn size_prefixed_root_as_runner_msg(
    buf: &[u8],
) -> Result<RunnerMsg, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<RunnerMsg>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RunnerMsg` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_runner_msg_unchecked`.
pub fn root_as_runner_msg_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<RunnerMsg<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<RunnerMsg<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RunnerMsg` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_runner_msg_unchecked`.
pub fn size_prefixed_root_as_runner_msg_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<RunnerMsg<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<RunnerMsg<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RunnerMsg and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RunnerMsg`.
pub unsafe fn root_as_runner_msg_unchecked(buf: &[u8]) -> RunnerMsg {
    flatbuffers::root_unchecked::<RunnerMsg>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RunnerMsg and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RunnerMsg`.
pub unsafe fn size_prefixed_root_as_runner_msg_unchecked(buf: &[u8]) -> RunnerMsg {
    flatbuffers::size_prefixed_root_unchecked::<RunnerMsg>(buf)
}
#[inline]
pub fn finish_runner_msg_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<RunnerMsg<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_runner_msg_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<RunnerMsg<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
